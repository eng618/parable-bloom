## Copilot / AI Agent Instructions — Parable Bloom

Be concise. Prioritize solver/provider integrity, Hive-backed persistence, and level data fidelity.

- **Big picture**: Flutter + Flame game. Riverpod providers drive state; Hive is the on-device source of truth; `LevelSolverService` (BFS, canonical) lives in [lib/features/game/domain/services/level_solver_service.dart](lib/features/game/domain/services/level_solver_service.dart) and powers blocking/unblocking logic.
- **Key files**: [lib/providers/game_providers.dart](lib/providers/game_providers.dart) (providers, solver integration, notifiers), [lib/main.dart](lib/main.dart) (Hive init/ProviderScope), [lib/features/game/presentation/widgets/garden_game.dart](lib/features/game/presentation/widgets/garden_game.dart) (Flame bridge), [lib/features/game/domain/repositories/game_progress_repository.dart](lib/features/game/domain/repositories/game_progress_repository.dart) (repo contracts), [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) for rationale.
- **State/persistence rules**: `moduleProgressProvider`, `vineStatesProvider`, `graceProvider`, `currentLevelProvider`, and `gameInstanceProvider` are the authoritative flows—extend/override via providers, not ad-hoc globals. `GameProgressNotifier` and `ModuleProgressNotifier` write directly to Hive; prefer introducing `ProgressRepository` adapters (Hive + Firebase) rather than bypassing existing writes.
- **Level format**: JSON under [assets/levels](assets/levels) with `grid_size` `[rows, cols]`, coordinate `ordered_path` using origin `(0,0)` lower-left, optional `mask` (`hide`/`show`/`show-all`) for visuals only. Update [pubspec.yaml](pubspec.yaml) assets when adding folders. Keep rectangular-grid assumptions intact (non-square allowed).
- **Patterns**: Keep UI thin; complex logic belongs in Riverpod notifiers/`LevelSolverService`. Use the coordinate-based solver in [lib/features/game/domain/services/level_solver_service.dart](lib/features/game/domain/services/level_solver_service.dart); avoid deprecated stubs. Maintain local-first behavior—Hive stays the primary store even when adding Firebase; wire cloud through the repository/provider layer.
- **Workflows**: `flutter pub get`, `flutter run`, `flutter test`, targeted solver tests `flutter test test/level_validation_test.dart`, `flutter format lib/`, `flutter analyze`. Level data checks: `python scripts/validate_levels.py` (or `validate_levels_enhanced.py`) before shipping new JSON.
- **Testing focus**: Level/solver behavior in [test/level_validation_test.dart](test/level_validation_test.dart) and animation logic in [test/vine_animation_test.dart](test/vine_animation_test.dart). Use provider overrides for deterministic tests. When changing persistence, add or update cases in [test/hive_repository_test.dart](test/hive_repository_test.dart) or the mock in [test/mock_repository_example_test.dart](test/mock_repository_example_test.dart).
- **Integration points**: `gameInstanceProvider` bridges Riverpod <-> Flame; changes here affect rendering lifecycle. Hive boxes are opened in [lib/main.dart](lib/main.dart); keep initialization early and awaited before `runApp`. Coordinate/animation history drives clear/blocked states—do not shortcut through the UI layer.
- **Conventions**: Prefer double quotes and `const` where possible (see [.clinerules/coding-standards.md](.clinerules/coding-standards.md)). Keep providers in dedicated files; add `copyWith`/equality for data classes; document non-obvious logic with brief comments. Use clean architecture with feature-based organization: data/domain/presentation layers.
- **When adding cloud sync**: Create `ProgressRepository` implementations (Hive + Firebase) and swap via a provider override; do not delete Hive paths. Document migration notes in [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md).
- **CI/quality**: Run `flutter test`, `flutter analyze`, `flutter format lib/` after changes. Repository policy expects Codacy CLI analysis per edited file; when adding dependencies, run a Trivy scan via Codacy. Keep changes small; update architecture docs if altering state/persistence boundaries.

If any section feels thin (e.g., provider wiring or level JSON examples), say which area to expand and I’ll add targeted guidance.
